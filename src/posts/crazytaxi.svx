---
title: Reverse Engineering Crazy Taxi
description: For some reason I put Crazy Taxi into the browser and You Can Too
date: 2/7/2026
---

<script>
    import HexEditor from "$lib/posts/crazy-taxi/HexEditor.svelte";
    import * as CTData from "$lib/posts/crazy-taxi/data.ts";
    import Table from "$lib/components/Table.svelte";
</script>

From time to time, and usually in the winter, a certain madness takes hold of me. Cooped up indoors from nasty weather and depressing grey vistas, I'll sink my teeth into an unreasonably sized engineering task and usually not let go for months. My friends have dubbed this my [strange moods](https://dwarffortresswiki.org/index.php/Strange_mood), named after a phenomenon in the game Dwarf Fortress where dwarves will stop whatever they are doing and pursue the construction of some ornate artifact, usually to the exclusion of everything else.

This year, my winter madness project was adding the classic game _Crazy Taxi_ to [noclip.website](https://noclip.website), my friend [Jasper's](https://www.youtube.com/@JasperRLZ) insanely cool and ambitious project. noclip calls itself a "digital museum of video game levels", and I think that's a great way to summarize its goal: it allows users to freely explore, in the browser, 3D recreations of hundreds of maps from dozens of video games ranging from the N64 era to relatively modern PC games, while also representing an [open source recreation of _each of those games'_ original rendering methods](https://github.com/magcius/noclip.website/).

That's because one of Jasper's rules for contributions to the site is that each added game must operate using the game's original files; no Blender exports, no pre-processing with modding tools, just rendering the game from its original files, all in the browser. That means adding a game to noclip involves effectively reverse engineering and recreating major portions of that game's code, from custom parsers for bespoke file formats, to rendering loops which often resemble the original game engine, to occasionally recreating parts of the game's AI and mechanics (seriously, check out the Bullet Bills in Super Mario Galaxy's [Buoy Base Galaxy](https://noclip.website/#smg/OceanFloaterLandGalaxy) level; you might just find an easter egg).

So before we move on, I highly recommend taking a minute to explore the various games and levels on noclip. There's a seriously good chance that it has at least one game you adore, and getting to freely fly around the 3D spaces you might've last experienced as a child is an amazing experience. It should also hopefully communicate the scope of what adding a game to the site entails!

## What were we talking about again

Back to my winter madness. In previous years I contributed two fairly large games to noclip, _Halo_ and _World of Warcraft_, so I was fairly familiar with the process of reverse engineering a game and writing a renderer for it. However, for both of those games there already existed substantial modding communities and copious amounts of technical documentation for how the games worked, down to detailed byte-level diagrams of each file format. This made it more approachable (though definitely not _easy_) to write those games' renderers, and I owe those communities a huge debt of gratitude for their documentation efforts.

But this year, I wanted to try something new: I decided I'd add a game to noclip that wasn't already understood, didn't already have the secrets of its file formats neatly displayed on a community wiki, and that didn't have any tools already for viewing its maps. And, thanks largely to my recent acquisition of a [Flippy Drive](https://www.crowdsupply.com/team-offbroadway/flippydrive) for my GameCube, I recently became re-enamored with _Crazy Taxi_, and thus my fate was sealed.

And so, this blog post is going to be a whirlwind tour of how I reverse engineered Crazy Taxi from (mostly) scratch, and created a renderer for it in noclip. This won't really be a tutorial on noclip.website development as such, though we will talk a bit about how my renderer works. Instead, my goal here is to describe the process of reversing in a way that is instructive, so that someone with a basic grasp of programming and maybe some 3D graphics chops can easily follow along, and hopefully feel like they too could've reversed the game. Wherever possible, I'll try to stick to the actual sequence of events leading to the game being on noclip, pointing out the lessons I learned along the way. Also, since Jasper was a close advisor during this whole process, I'll be sure to point out whenever something was a suggestion or addition from him.

## First steps

So, you've decided to reverse engineer Crazy Taxi. That's great, but _which version_ of Crazy Taxi are we talking about? After all, the game was first released for arcade cabinets in 1999, then was ported to the Sega Dreamcast in 2000, then to Sony PlayStation 2 and Nintendo GameCube in 2001, then to the PC in 2002, then to iOS in 2012, and Android in 2013. Many of these ports were done by different studios and use totally different file formats, engines, and even feature different gameplay mechanics. So which game are we talking about here?

Because I'd been playing the GameCube version of the game, and since Jasper has developed something of a toolkit for GameCube games on noclip, I was naturally inclined towards that version. However, as Jasper pointed out, the Android version apparently shipped with its [debug symbols](https://en.wikipedia.org/wiki/Debug_symbol), which would make reverse engineering it substantially easier. And while this Android version will prove useful to us later, it was the GameCube version that I ended up opting for, so I acquired a disc image ROM of the game.

## Tools of the trade

Now that we have some actual game bytes to work with, let's take a second to talk about our tools. While I'm by no means prescriptive of this, there are some tools that are pretty standard for reverse engineering for good reason:

* A hex editor. Whenever you're working files containing unknown data, a hex editor is absolutely crucial. In fact, it's so important to this process that I ended up writing a custom one for use in this post! For this project, I used [ImHex](https://imhex.werwolv.net), but any editor that allows previewing common datatypes will do.
* [Dolphin, the GameCube and Wii emulator](https://dolphin-emu.org). As you might expect, being able to actually play the game and see levels will be invaluable as it provides us with a ground truth to compare our renderer against. But Dolphin actually provides us with an bunch of other very useful tooling. It can extract ROMs into their constitutent files, has a fairly decent debugger complete with breakpoints, and it has an incredibly useful set of tools for analyzing the graphical instructions sent to the emulated GameCube's GPU.
* A disassembler/decompiler. I used [Ghidra](https://github.com/NationalSecurityAgency/ghidra) for this project since, despite being developed by a greatly reviled three-letter-agency, it _is_ free and has a good deal of documentation available. Tools like Ghidra allow us to incrementally study, annotate, and eventually understand the assembly language baked into the game's binary.
* And lastly, noclip.website itself. Jasper has built up an insanely versatile 3D graphics toolkit in this project, and being able to visualize the data we're extracting from Crazy Taxi in 3D space allows us to quickly test our assumptions as we're navigating a ton of unknowns. As you'll see, before I even nailed down many of the models and textures of the game, I was able to use noclip to visualize data found in the binary, helping me draw conclusions on how the game was laid out.

## A lay of the land

At last, we're ready to start looking at some bytes. The Crazy Taxi ROM I have, `Crazy Taxi (USA).rvz`, is about 90MB, which is considerably smaller than the average GameCube ROM at 1.4GB. While I could load this up into a hex editor and get to sleuthin', I happen to already know that `.rvz` is a file format used by the Dolphin project as a more compact alternative to `.iso`, another disc image format. And luckily, Dolphin has tools for opening and extracting these: set the ROM's directory as Dolphin's game directory, right-click on the game and select Properties, then click on the Filesystem tab:

![Dolphin's Filesystem view](/images/crazy-taxi/dolphin-filesystem.png)

From here, you can right-click on "Disc 1 - GCTE51", and then extract the entire disc somewhere on your computer. Great, now we're actually able to read some game data!

Let's see what we're working with here:

<pre class="max-h-96">
$ tree ct-extract/
ct-extract/
├── files
│   ├── ct
│   │   ├── aklmmpeg.all
│   │   ├── arial12.fnt
│   │   ├── colDC1.bin
│   │   ├── colDC2.bin
│   │   ├── colDC3.bin
│   │   ├── courrier32.fnt
│   │   ├── CT.txt
│   │   ├── ctlogoL.wav
│   │   ├── ctlogoR.wav
│   │   ├── cube0.shp
│   │   ├── Files.tmp
│   │   ├── landac
│   │   │   ├── land01.tex
│   │   │   ├── ...
│   │   │   └── land33.tex
│   │   ├── landac.all
│   │   ├── landdc
│   │   │   ├── land01.tex
│   │   │   ├── ...
│   │   │   └── land29.tex
│   │   ├── landdc.all
│   │   ├── legalscr.tex
│   │   ├── misc.all
│   │   ├── misc.lst
│   │   ├── motDC.bin
│   │   ├── music
│   │   │   ├── alliwant.adp
│   │   │   ├── ...
│   │   │   └── waydown.adp
│   │   ├── objDC1.bin
│   │   ├── objDC2.bin
│   │   ├── objDC3.bin
│   │   ├── polDC0.all
│   │   ├── poldc1_stream.all
│   │   ├── poldc1.all
│   │   ├── poldc2_stream.all
│   │   ├── poldc2.all
│   │   ├── poldc3_stream.all
│   │   ├── poldc3.all
│   │   ├── recAdvAC.bin
│   │   ├── recAdvDC.bin
│   │   ├── recEndAC.bin
│   │   ├── recEndDC.bin
│   │   ├── samples.all
│   │   ├── SegaMpeg.all
│   │   ├── sizes.dat
│   │   ├── sizes.txt
│   │   ├── splDC1.bin
│   │   ├── splDC2.bin
│   │   ├── splDC3.bin
│   │   ├── sprADV.all
│   │   ├── ...
│   │   ├── sprTSPA.all
│   │   ├── texDC0.all
│   │   ├── texDC1.all
│   │   ├── texDC2.all
│   │   ├── texdc3.all
│   │   ├── TEXTURE.tex
│   │   ├── voice_a.all
│   │   ├── voice_b.all
│   │   ├── voice_c.all
│   │   ├── voice_d.all
│   │   ├── voices.all
│   │   └── white.tex
│   └── opening.bnr
└── sys
    ├── apploader.img
    ├── bi2.bin
    ├── boot.bin
    ├── fst.bin
    └── main.dol

7 directories, 148 files
</pre>

I took some liberties in abbreviating the listing here, but besides a couple `.wav` and `.txt` files, there's a whole lotta file extensions I don't recognize. Googling them doesn't really get us anywhere either, which leads me to think these are proprietary files designed by the GameCube port's developer, Acclaim.

While we don't know yet what these files are, we can certainly make some _educated guesses_ about the purposes of some of them. `.tex` sure sounds like it's probably used for textures, `.shp` kinda resembles the word "shape", so maybe it has to do with polygon data. And in the suspiciously named `music/` directory, we have a couple `.adp` files that have the names of the songs in the game, so maybe they're audio files? Googling "audio adp file", I found [this resource](http://fileformats.archiveteam.org/wiki/Nintendo_GameCube_/_Wii_ADP), which checks out.

These `.all` files look the most promising to me, though, since they comprise the majority of the game's data (outside the binary itself), so let's start there.

## All's well that ends `.all`

`.all` as an extension name is pretty vague, but based on the wide variety of filenames using it (e.g. `voices.all`, `texDC0.all`, `polDC0.all`), we might guess it's some general purpose file format. Here's the first couple hundred bytes of the smallest of these, `files/ct/poldc3.all`:

<HexEditor title="poldc3.all" data={CTData.poldc3_0_576} />

If you've never looked at data in a hex editor before, here's a quick tour of what what's going on here. In the middle, we have the file contents of `poldc3.all` in hexadecimal form, followed by an ASCII representation of the same data (with a dim grey `.` representing unprintable ASCII characters). Running down the left column are the file offsets into `poldc3.all` where each line of bytes occurs. And on the bottom, we have a panel which shows different interpretations of the currently selected data: as signed & unsigned integers of various bit lengths, and as a 16-bit and 32-bit floating point numbers. Finally, there's a toggle on whether to interpret the data as [big-endian or little-endian](https://en.wikipedia.org/wiki/Endianness). You can click on any byte (or ASCII character) to select a 4-byte sequence for interpretation.

Something that's immediately evident here is there appear to be filenames of `.shp` files at regular intervals, along with some other non-ASCII values. If you click around the editor, you can get a sense of what these values might represent, even if we don't yet know their actual format. For example, assuming little-endian values (I'll get back to endianness in a second), the first value looks like it's almost certainly the integer `7` since the floating point values are way too small to be likely candidates. And, wouldn't you know it, there happen to be 7 filenames following it, followed by some data that seems to break from the pattern. This gives us our first testable theory about the file: **the first number in an `.all` file might represent how many filenames follow it**.

As for which endianness to choose, there's a long and a short answer here. The short answer is I usually toggle between the two until values start looking "reasonable", i.e. values around the order of magnitude I'd expect for a game. Let's save the long answer for later, since this will come up again soon, but for now we'll stick with little-endian since that seems to work best for this data.

## A sample size of 1

Back to our theory. To see if it holds any water, let's check out the first kilobyte or so of another relatively small `.all` file, `files/ct/sprCENG.all`:

<HexEditor title="sprCENG.all" data={CTData.sprCENG_0_1456 } />

Once again, we have a pretty unambigious integer value starting at the first byte, and this time it's `0x13`, or `19` in decimal, which again matches the number of strings we see immediately following it. That said, we still aren't sure whether that first integer is 8 bits, 16 bits, or 32 bits long. But a pattern is definitely emerging! Checking a few more files, I see this pattern holds even for very large `.all`s, and also notice that the first four bytes is never occupied with anything except for this integer value. This leads me to update our theory: **the first four bytes is an unsigned 32-bit (4-byte) integer representing the number of filenames following it**.

## An archive of our own

At this point, because I've reverse engineered a number of file formats before, I've also made a guess as to the purpose of `.all` files: **they represent some kind of _archive_ file that can contain a number of other named files**, sort of like a tarball.

Archive files are common in video games for the same reason they're common in lots of contexts where many files are read: I/O is expensive! If you can frontload operations that take a long time, like loading a bunch of related files from a spinning disc, it's easier to guarantee reliably fast operations on that data later. And importantly, archive file formats tend to start with some kind of table of contents which lists their constituent files, as well as some info on where to find them, such as offsets to their start/end, or their length. Since that seems to be what we're looking at, let's see if we can determine the format of our table of contents.

Looking at our two example `.all`s, we can see that after the first four bytes a repeating pattern of values occurs: `0x20 0x00 0x41 0x00`, followed by 8 null bytes. Checking a bunch of other `.all`s, it seems they all share this pattern, so it doesn't seem to vary based on the number of filenames or any other factor. Since they seem to be constant, let's ignore them for now. Finally, at offset `0x10`, we see our first filename.

Now, for `sprCENG.all`, we know our archive contains 19 files, so in addition to the 19 filenames we'd also expect to find that many values describing how to find them. These values might be interleaved with the filenames, or might be listed as their own contiguous array. Looking at our data, there _is_ a suspicious non-ASCII value that's interleaved between filenames, so I think we're looking at an array of filename/value pairs. And when we have an array of structures like this, a good first step is to figure out whether the elements are of fixed or variable length.

If they were variable length, we'd expect to see another integer value describing how long each item is, but I don't see anything like that. Instead, just eyeballing the data, it looks like these items are all the same length!

To find that fixed length, just try counting the number of bytes from the start of the first filename (`ST_mode_s_eng01.tex`) to the start of the second (`ST_mode_s_eng01b.tex`): 68 bytes. And, indeed, checking the distance from the second to the third filename is _also_ 68 bytes. Seems we have another theory: **each table of contents item is 68 bytes long**.

## Writing our first parser

Looking at any 68 byte chunk, it seems there's not much going on besides the filename and the few non-ASCII bytes at the end. Similar to our analysis of the entire item, we might note that the strings don't have a length value associated with them, so let's assume they're also a fixed length of 64 bytes (i.e. all but the last 4 bytes). With that, we now have enough of a working theory to write our first parser!

This might feel premature, since we still don't know what half of these values are, and we haven't even touched the other 80% of the data. But writing a parser is a crucial step towards testing the theories we have so far, and will tell us much more than eyeballing the data ever could. So let's codify our theories about the `.all` format into some pseudocode:

```
struct ArchiveHeader {
    u32 num_files,
    u16 unk0,
    u16 unk1,
    u8 empty[8],
    TableOfContentsEntry toc[num_files],
}

struct TableOfContentsEntry {
    char filename[64],
    u32 unk0,
}
```

Note that even though we don't know what many of these fields are, we've still given them types and names (`unk` being a very common abbreviation of "unknown") which we will fill in later as we learn more.

In my actual code, I use a lovely little Rust library called [deku](https://docs.rs/deku/latest/deku/) which lets me write the entire binary parser using structs and declarative macros like this:

```rust
#[derive(DekuRead, Debug)]
pub struct ArchiveHeader {
    n_items: u32,
    unk0: u16,
    unk1: u16,
    #[deku(pad_bytes_before = "8", count = "n_items")]
    toc: Vec<TableOfContentsEntry>,
}

#[derive(DekuRead, Debug)]
pub struct TableOfContentsEntry {
    #[deku(count = "64")
    filename: Vec<u8>, // `char` is UTF8 which deku doesn't naively parse
    unk0: u32,
}
```

Now we can test our theory by simply running the parser on every `.all` file we've got. As it happens, it's correct (yay), but you can imagine how having garbage `filename` values or parsing a value of `12,000,000` for `n_items` might indicate we've gone astray somewhere. This brings us to a really significant lesson I've learned while reverse engineering: **as early as humanly possible, test your theories with actual code**. I can't tell you how much time I've wasted by working based on untested assumptions, only to find out they were wrong hours later.

## `unk` status

Anyway, since it seems we're on the right track, let's figure out what `TableOfContentsEntry.unk0` represents by taking another look at `poldc3.all`:

<HexEditor title="poldc3.all" data={CTData.poldc3_0_576} />

Using our parser, let's print out what each of the 7 `TableOfContentsEntry` values are:

<Table
    header={[`filename`, `unk0 (in decimal)`]}
    rows={[
        ["ET_beachflag.shp", 1312],
        ["pin.shp", 4160],
        ["ET_breakbal1.shp", 7456],
        ["ET_snow1.shp", 576],
        ["ET_snow2.shp", 608],
        ["WhiteSphere.shp", 12128],
        ["triangle_12.shp", 576],
    ]}
    caption={"All `TableOfContentsEntry` values parsed from `poldc3.all`"}
    />

If `unk0` represented an offset into the file, I'd expect there to be a value close to where the table of contents data stops, which is around `0x1F0` or `496`, and also perhaps for the entries to be in increasing offset order. Since we don't see either of those, let's instead guess that `unk0` represents the size of each file. Then, the pseudocode for extracting the files from these `.all` archives would look roughly like this:

```
header = ArchiveHeader.parse(archive_file)
// advance to the end of the header section
pos = sizeof(header)
for entry in header.toc:
    file_size = entry.unk0
    file_data = archive_file[pos..pos+file_size]
    write_file(entry.filename, file_data)
    pos += file_size
```

And this pretty much works! There's one more caveat where each file's data is aligned to the nearest multiple of `0x20` bytes, which you can see in `poldc3.all` (the first file data starts at `0x200` instead of right after the last `TableOfContentsEntry`), but otherwise I was able to use this procedure to fully extract every file from every `.all` archive. So now we can update our definition of `TableOfContentsEntry`:

```rust
#[derive(DekuRead, Debug)]
pub struct TableOfContentsEntry {
    #[deku(count = "64")
    filename: Vec<u8>, // `char` is UTF8 which deku doesn't naively parse
    file_size: u32,     // no longer unknown!
}
```
